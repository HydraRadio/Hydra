{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Hydra API documentation Example simulations ( example ) Point source sampler ( ptsrc_sampler ) Diffuse emission region sampler ( region_sampler ) Spherical harmonic sampler ( sh_sampler )","title":"Hydra API documentation"},{"location":"#hydra-api-documentation","text":"Example simulations ( example ) Point source sampler ( ptsrc_sampler ) Diffuse emission region sampler ( region_sampler ) Spherical harmonic sampler ( sh_sampler )","title":"Hydra API documentation"},{"location":"example/","text":"Example simulations ( example ) generate_random_ptsrc_catalogue(Nptsrc, ra_bounds, dec_bounds, logflux_bounds=(-1.0, 2.0)) Generate a catalogue of point sources with random positions and log(flux) values. Parameters: Name Type Description Default Nptsrc int Number of point sources in catalogue. required ra_bounds tuple of float Tuple with the lower and upper bounds of the RA range, in radians. Sources will be placed according to a uniform random distribution within the specified interval. required dec_bounds tuple of float Same as above, but for the declination range. required logflux_bounds tuple of float The lower and upper bounds of log10(flux) at some reference frequency. The reference frequency is not specified here, so these values can be treated purely as amplitude/scaling factors. Sources will be randomly assigned fluxes/amplitudes in this interval in log10(flux). (-1.0, 2.0) Returns: Name Type Description ra array_like RA values for the sources, in radians. dec array_like Dec values for the sources, in radians. ptsrc_amps array_like Amplitude or flux values at an unspecified reference frequency. Source code in hydra/example.py def generate_random_ptsrc_catalogue( Nptsrc, ra_bounds, dec_bounds, logflux_bounds=(-1.0, 2.0) ): \"\"\" Generate a catalogue of point sources with random positions and log(flux) values. Parameters: Nptsrc (int): Number of point sources in catalogue. ra_bounds (tuple of float): Tuple with the lower and upper bounds of the RA range, in radians. Sources will be placed according to a uniform random distribution within the specified interval. dec_bounds (tuple of float): Same as above, but for the declination range. logflux_bounds (tuple of float): The lower and upper bounds of log10(flux) at some reference frequency. The reference frequency is not specified here, so these values can be treated purely as amplitude/scaling factors. Sources will be randomly assigned fluxes/amplitudes in this interval in log10(flux). Returns: ra (array_like): RA values for the sources, in radians. dec (array_like): Dec values for the sources, in radians. ptsrc_amps (array_like): Amplitude or flux values at an unspecified reference frequency. \"\"\" # Get coordinate bounds ra_low, ra_high = (min(ra_bounds), max(ra_bounds)) dec_low, dec_high = (min(dec_bounds), max(dec_bounds)) logflux_low, logflux_high = (min(logflux_bounds), max(logflux_bounds)) # Generate random point source locations # RA goes from [0, 2 pi] and Dec from [-pi / 2, +pi / 2]. ra = np.random.uniform(low=ra_low, high=ra_high, size=Nptsrc) # Inversion sample to get them uniform on the sphere, in case wide bounds are used U = np.random.uniform(low=0, high=1, size=Nptsrc) dsin = np.sin(dec_high) - np.sin(dec_low) dec = np.arcsin( U * dsin + np.sin(dec_low) ) # np.arcsin returns on [-pi / 2, +pi / 2] # Generate fluxes ptsrc_amps = 10.0 ** np.random.uniform( low=logflux_low, high=logflux_high, size=Nptsrc ) return ra, dec, ptsrc_amps run_example_simulation(times, freqs, output_dir, ra, dec, ptsrc_amps, array_latitude, beam_type='gaussian', hex_array=(3, 4)) Run an example visibility simulation for testing purposes, using semi-realistic beams, randomly placed point sources, and a hexagonal array layout. Parameters: Name Type Description Default times array_like Time array, i.e. local sidereal time (LST), in radians. required freqs array_like Frequency array, in MHz. required output_dir str Unused. required ra array_like RA values for the sources, in radians. required dec array_like Dec values for the sources, in radians. required ptsrc_amps array_like Amplitude or flux values at an unspecified reference frequency. required array_latitude float Array latitude in radians. required hex_array tuple Tuple of length 2 specifying the number of antennas in the first and central rows of a regular symmetric hexagonal array. (3, 4) beam_type str The type of beam model to use for the simulations. Can be 'polybeam' or 'gaussian'. 'gaussian' Returns: Name Type Description model0 array_like Model visibility computed by the simulator. The shape is given by extract_vis_from_sim() . fluxes array_like Point source fluxes, per source and per frequency. beams list List of UVBeam or AnalyticBeam -compatible beam objects. ant_info tuple Tuple of arrays and dictionaries containing antenna information, in the order: (ants, ant_pos, antpairs, ants1, ants2) . Source code in hydra/example.py def run_example_simulation( times, freqs, output_dir, ra, dec, ptsrc_amps, array_latitude, beam_type='gaussian', hex_array=(3,4), ): \"\"\" Run an example visibility simulation for testing purposes, using semi-realistic beams, randomly placed point sources, and a hexagonal array layout. Parameters: times (array_like): Time array, i.e. local sidereal time (LST), in radians. freqs (array_like): Frequency array, in MHz. output_dir (str): Unused. ra (array_like): RA values for the sources, in radians. dec (array_like): Dec values for the sources, in radians. ptsrc_amps (array_like): Amplitude or flux values at an unspecified reference frequency. array_latitude (float): Array latitude in radians. hex_array (tuple): Tuple of length 2 specifying the number of antennas in the first and central rows of a regular symmetric hexagonal array. beam_type (str): The type of beam model to use for the simulations. Can be 'polybeam' or 'gaussian'. Returns: model0 (array_like): Model visibility computed by the simulator. The shape is given by `extract_vis_from_sim()`. fluxes (array_like): Point source fluxes, per source and per frequency. beams (list): List of `UVBeam` or `AnalyticBeam`-compatible beam objects. ant_info (tuple): Tuple of arrays and dictionaries containing antenna information, in the order: `(ants, ant_pos, antpairs, ants1, ants2)`. \"\"\" # Dimensions of simulation hex_array = tuple(hex_array) assert len(hex_array) == 2, \"hex-array argument must have length 2.\" # Set up array and data properties ant_pos = build_hex_array(hex_spec=hex_array, d=14.6) ants = np.array(list(ant_pos.keys())) Nants = len(ants) # Set up baselines antpairs = [] for i in range(len(ants)): for j in range(i, len(ants)): if i != j: # Exclude autos antpairs.append((i, j)) ants1, ants2 = list(zip(*antpairs)) beta_ptsrc = -2.7 fluxes = get_flux_from_ptsrc_amp(ptsrc_amps, freqs, beta_ptsrc) ##np.save(os.path.join(output_dir, \"ptsrc_amps0\"), ptsrc_amps) ##np.save(os.path.join(output_dir, \"ptsrc_coords0\"), np.column_stack((ra, dec)).T) # Beams if \"polybeam\" in beam_type.lower(): # PolyBeam fitted to HERA Fagnoni beam beam_coeffs = [ 0.29778665, -0.44821433, 0.27338272, -0.10030698, -0.01195859, 0.06063853, -0.04593295, 0.0107879, 0.01390283, -0.01881641, -0.00177106, 0.01265177, -0.00568299, -0.00333975, 0.00452368, 0.00151808, -0.00593812, 0.00351559, ] beams = [ PolyBeam(beam_coeffs, spectral_index=-0.6975, ref_freq=1.0e8) for ant in ants ] else: beams = [ pyuvsim.analyticbeam.AnalyticBeam(\"gaussian\", diameter=14.0) for ant in ants ] # Run a simulation t0 = time.time() _sim_vis = simulate_vis( ants=ant_pos, fluxes=fluxes, ra=ra, dec=dec, freqs=freqs * 1e6, # MHz -> Hz lsts=times, beams=beams, polarized=False, precision=2, latitude=array_latitude, use_feed=\"x\", ) # timing_info(ftime, 0, \"(0) Simulation\", time.time() - t0) # print(\"(0) Simulation\", time.time() - t0) # Allocate computed visibilities to only the requested baselines (saves memory) model0 = extract_vis_from_sim(ants, antpairs, _sim_vis) del _sim_vis # save some memory # Return ant_info = (ants, ant_pos, antpairs, ants1, ants2) return model0, fluxes, beams, ant_info","title":"Example simulations (example)"},{"location":"example/#example-simulations-example","text":"","title":"Example simulations (example)"},{"location":"example/#hydra.example.generate_random_ptsrc_catalogue","text":"Generate a catalogue of point sources with random positions and log(flux) values. Parameters: Name Type Description Default Nptsrc int Number of point sources in catalogue. required ra_bounds tuple of float Tuple with the lower and upper bounds of the RA range, in radians. Sources will be placed according to a uniform random distribution within the specified interval. required dec_bounds tuple of float Same as above, but for the declination range. required logflux_bounds tuple of float The lower and upper bounds of log10(flux) at some reference frequency. The reference frequency is not specified here, so these values can be treated purely as amplitude/scaling factors. Sources will be randomly assigned fluxes/amplitudes in this interval in log10(flux). (-1.0, 2.0) Returns: Name Type Description ra array_like RA values for the sources, in radians. dec array_like Dec values for the sources, in radians. ptsrc_amps array_like Amplitude or flux values at an unspecified reference frequency. Source code in hydra/example.py def generate_random_ptsrc_catalogue( Nptsrc, ra_bounds, dec_bounds, logflux_bounds=(-1.0, 2.0) ): \"\"\" Generate a catalogue of point sources with random positions and log(flux) values. Parameters: Nptsrc (int): Number of point sources in catalogue. ra_bounds (tuple of float): Tuple with the lower and upper bounds of the RA range, in radians. Sources will be placed according to a uniform random distribution within the specified interval. dec_bounds (tuple of float): Same as above, but for the declination range. logflux_bounds (tuple of float): The lower and upper bounds of log10(flux) at some reference frequency. The reference frequency is not specified here, so these values can be treated purely as amplitude/scaling factors. Sources will be randomly assigned fluxes/amplitudes in this interval in log10(flux). Returns: ra (array_like): RA values for the sources, in radians. dec (array_like): Dec values for the sources, in radians. ptsrc_amps (array_like): Amplitude or flux values at an unspecified reference frequency. \"\"\" # Get coordinate bounds ra_low, ra_high = (min(ra_bounds), max(ra_bounds)) dec_low, dec_high = (min(dec_bounds), max(dec_bounds)) logflux_low, logflux_high = (min(logflux_bounds), max(logflux_bounds)) # Generate random point source locations # RA goes from [0, 2 pi] and Dec from [-pi / 2, +pi / 2]. ra = np.random.uniform(low=ra_low, high=ra_high, size=Nptsrc) # Inversion sample to get them uniform on the sphere, in case wide bounds are used U = np.random.uniform(low=0, high=1, size=Nptsrc) dsin = np.sin(dec_high) - np.sin(dec_low) dec = np.arcsin( U * dsin + np.sin(dec_low) ) # np.arcsin returns on [-pi / 2, +pi / 2] # Generate fluxes ptsrc_amps = 10.0 ** np.random.uniform( low=logflux_low, high=logflux_high, size=Nptsrc ) return ra, dec, ptsrc_amps","title":"generate_random_ptsrc_catalogue"},{"location":"example/#hydra.example.run_example_simulation","text":"Run an example visibility simulation for testing purposes, using semi-realistic beams, randomly placed point sources, and a hexagonal array layout. Parameters: Name Type Description Default times array_like Time array, i.e. local sidereal time (LST), in radians. required freqs array_like Frequency array, in MHz. required output_dir str Unused. required ra array_like RA values for the sources, in radians. required dec array_like Dec values for the sources, in radians. required ptsrc_amps array_like Amplitude or flux values at an unspecified reference frequency. required array_latitude float Array latitude in radians. required hex_array tuple Tuple of length 2 specifying the number of antennas in the first and central rows of a regular symmetric hexagonal array. (3, 4) beam_type str The type of beam model to use for the simulations. Can be 'polybeam' or 'gaussian'. 'gaussian' Returns: Name Type Description model0 array_like Model visibility computed by the simulator. The shape is given by extract_vis_from_sim() . fluxes array_like Point source fluxes, per source and per frequency. beams list List of UVBeam or AnalyticBeam -compatible beam objects. ant_info tuple Tuple of arrays and dictionaries containing antenna information, in the order: (ants, ant_pos, antpairs, ants1, ants2) . Source code in hydra/example.py def run_example_simulation( times, freqs, output_dir, ra, dec, ptsrc_amps, array_latitude, beam_type='gaussian', hex_array=(3,4), ): \"\"\" Run an example visibility simulation for testing purposes, using semi-realistic beams, randomly placed point sources, and a hexagonal array layout. Parameters: times (array_like): Time array, i.e. local sidereal time (LST), in radians. freqs (array_like): Frequency array, in MHz. output_dir (str): Unused. ra (array_like): RA values for the sources, in radians. dec (array_like): Dec values for the sources, in radians. ptsrc_amps (array_like): Amplitude or flux values at an unspecified reference frequency. array_latitude (float): Array latitude in radians. hex_array (tuple): Tuple of length 2 specifying the number of antennas in the first and central rows of a regular symmetric hexagonal array. beam_type (str): The type of beam model to use for the simulations. Can be 'polybeam' or 'gaussian'. Returns: model0 (array_like): Model visibility computed by the simulator. The shape is given by `extract_vis_from_sim()`. fluxes (array_like): Point source fluxes, per source and per frequency. beams (list): List of `UVBeam` or `AnalyticBeam`-compatible beam objects. ant_info (tuple): Tuple of arrays and dictionaries containing antenna information, in the order: `(ants, ant_pos, antpairs, ants1, ants2)`. \"\"\" # Dimensions of simulation hex_array = tuple(hex_array) assert len(hex_array) == 2, \"hex-array argument must have length 2.\" # Set up array and data properties ant_pos = build_hex_array(hex_spec=hex_array, d=14.6) ants = np.array(list(ant_pos.keys())) Nants = len(ants) # Set up baselines antpairs = [] for i in range(len(ants)): for j in range(i, len(ants)): if i != j: # Exclude autos antpairs.append((i, j)) ants1, ants2 = list(zip(*antpairs)) beta_ptsrc = -2.7 fluxes = get_flux_from_ptsrc_amp(ptsrc_amps, freqs, beta_ptsrc) ##np.save(os.path.join(output_dir, \"ptsrc_amps0\"), ptsrc_amps) ##np.save(os.path.join(output_dir, \"ptsrc_coords0\"), np.column_stack((ra, dec)).T) # Beams if \"polybeam\" in beam_type.lower(): # PolyBeam fitted to HERA Fagnoni beam beam_coeffs = [ 0.29778665, -0.44821433, 0.27338272, -0.10030698, -0.01195859, 0.06063853, -0.04593295, 0.0107879, 0.01390283, -0.01881641, -0.00177106, 0.01265177, -0.00568299, -0.00333975, 0.00452368, 0.00151808, -0.00593812, 0.00351559, ] beams = [ PolyBeam(beam_coeffs, spectral_index=-0.6975, ref_freq=1.0e8) for ant in ants ] else: beams = [ pyuvsim.analyticbeam.AnalyticBeam(\"gaussian\", diameter=14.0) for ant in ants ] # Run a simulation t0 = time.time() _sim_vis = simulate_vis( ants=ant_pos, fluxes=fluxes, ra=ra, dec=dec, freqs=freqs * 1e6, # MHz -> Hz lsts=times, beams=beams, polarized=False, precision=2, latitude=array_latitude, use_feed=\"x\", ) # timing_info(ftime, 0, \"(0) Simulation\", time.time() - t0) # print(\"(0) Simulation\", time.time() - t0) # Allocate computed visibilities to only the requested baselines (saves memory) model0 = extract_vis_from_sim(ants, antpairs, _sim_vis) del _sim_vis # save some memory # Return ant_info = (ants, ant_pos, antpairs, ants1, ants2) return model0, fluxes, beams, ant_info","title":"run_example_simulation"},{"location":"ptsrc_sampler/","text":"Point source sampler ( ptsrc_sampler ) calc_proj_operator(ra, dec, fluxes, ant_pos, antpairs, freqs, times, beams, latitude=-0.5361913261514378) Calculate a visibility vector for each point source, as a function of frequency, time, and baseline. This is the projection operator from point source amplitude to visibilities. Gains are not included. Parameters: Name Type Description Default ra, dec (array_like RA and Dec of each source, in radians. required fluxes array_like Flux for each point source as a function of frequency. required ant_pos dict Dictionary of antenna positions, [x, y, z], in m. The keys should be the numerical antenna IDs. required antpairs list of tuple List of tuples containing pairs of antenna IDs, one for each baseline. required freqs array_like Frequencies, in MHz. required times array_like LSTs, in radians. required beams list of UVBeam List of UVBeam objects, one for each antenna. required latitude float Latitude of the observing site, in radians. -0.5361913261514378 Returns: Name Type Description vis_proj_operator array_like The projection operator from source amplitudes to visibilities, from calc_proj_operator . This is an array of the visibility values for each source. Source code in hydra/ptsrc_sampler.py def calc_proj_operator( ra, dec, fluxes, ant_pos, antpairs, freqs, times, beams, latitude=-0.5361913261514378, ): \"\"\" Calculate a visibility vector for each point source, as a function of frequency, time, and baseline. This is the projection operator from point source amplitude to visibilities. Gains are not included. Parameters: ra, dec (array_like): RA and Dec of each source, in radians. fluxes (array_like): Flux for each point source as a function of frequency. ant_pos (dict): Dictionary of antenna positions, [x, y, z], in m. The keys should be the numerical antenna IDs. antpairs (list of tuple): List of tuples containing pairs of antenna IDs, one for each baseline. freqs (array_like): Frequencies, in MHz. times (array_like): LSTs, in radians. beams (list of UVBeam): List of UVBeam objects, one for each antenna. latitude (float): Latitude of the observing site, in radians. Returns: vis_proj_operator (array_like): The projection operator from source amplitudes to visibilities, from `calc_proj_operator`. This is an array of the visibility values for each source. \"\"\" Nptsrc = ra.size Nants = len(ant_pos) Nvis = len(antpairs) # Empty array of per-point source visibilities vis_ptsrc = np.zeros((Nvis, freqs.size, times.size, Nptsrc), dtype=np.complex128) # Get visibility for each point source # Returns shape (NFREQS, NTIMES, NANTS, NANTS, NSRCS) vis = simulate_vis_per_source( ants=ant_pos, fluxes=fluxes, ra=ra, dec=dec, freqs=freqs * 1e6, lsts=times, beams=beams, polarized=False, precision=2, latitude=latitude, use_feed=\"x\", ) # Allocate computed visibilities to only available baselines (saves memory) ants = list(ant_pos.keys()) for i, bl in enumerate(antpairs): idx1 = ants.index(bl[0]) idx2 = ants.index(bl[1]) vis_ptsrc[i, :, :, :] = vis[:, :, idx1, idx2, :] return vis_ptsrc precompute_mpi(comm, ants, antpairs, freq_chunk, time_chunk, proj_chunk, data_chunk, inv_noise_var_chunk, gain_chunk, amp_prior_std, realisation=True) Precompute the projection operator and matrix operator in parallel. The projection operator is computed in chunks in time and frequency. The overall matrix operator can be computed by summing the matrix operator for the time and frequency chunks. Source code in hydra/ptsrc_sampler.py def precompute_mpi( comm, ants, antpairs, freq_chunk, time_chunk, proj_chunk, data_chunk, inv_noise_var_chunk, gain_chunk, amp_prior_std, realisation=True, ): \"\"\" Precompute the projection operator and matrix operator in parallel. The projection operator is computed in chunks in time and frequency. The overall matrix operator can be computed by summing the matrix operator for the time and frequency chunks. \"\"\" # Make sure ants is an array ants = np.atleast_1d(ants) if comm is not None: myid = comm.Get_rank() else: myid = 0 # Check input dimensions assert data_chunk.shape == (len(antpairs), freq_chunk.size, time_chunk.size) assert data_chunk.shape == inv_noise_var_chunk.shape proj = proj_chunk.copy() # make a copy so we don't alter the original proj! # FIXME: Check for unused args! # Apply gains to projection operator for k, bl in enumerate(antpairs): ant1, ant2 = bl i1 = np.where(ants == ant1)[0][0] i2 = np.where(ants == ant2)[0][0] proj[k, :, :, :] *= ( gain_chunk[i1, :, :, np.newaxis] * gain_chunk[i2, :, :, np.newaxis].conj() ) # (2) Precompute linear system operator nsrcs = proj.shape[-1] my_linear_op = np.zeros((nsrcs, nsrcs), dtype=proj.real.dtype) # inv_noise_var has shape (Nbls, Nfreqs, Ntimes) v_re = (proj.real * np.sqrt(inv_noise_var_chunk[..., np.newaxis])).reshape( (-1, nsrcs) ) v_im = (proj.imag * np.sqrt(inv_noise_var_chunk[..., np.newaxis])).reshape( ((-1, nsrcs)) ) # Treat real and imaginary separately, and get copies, to massively # speed-up the matrix multiplication! my_linear_op[:, :] = v_re.T @ v_re + v_im.T @ v_im del v_re, v_im # Do Reduce (sum) operation to get total operator on root node linear_op = np.zeros( (1, 1), dtype=my_linear_op.dtype ) # dummy data for non-root workers if myid == 0: linear_op = np.zeros_like(my_linear_op) if comm is not None: comm.Reduce(my_linear_op, linear_op, op=MPI_SUM, root=0) else: linear_op = my_linear_op # Include prior and identity terms to finish constructing LHS operator on root worker if myid == 0: linear_op = np.eye(linear_op.shape[0]) + np.diag( amp_prior_std ) @ linear_op @ np.diag(amp_prior_std) # (3) Calculate linear system RHS proj = proj.reshape((-1, nsrcs)) realisation_switch = ( 1.0 if realisation else 0.0 ) # Turn random realisations on or off # Calculate residual of data vs fiducial model (residual from amplitudes = 1) # (proj now includes gains) resid_chunk = data_chunk.copy() - ( proj.reshape((-1, nsrcs)) @ np.ones_like(amp_prior_std) ).reshape(data_chunk.shape) # (Terms 1+3): S^1/2 A^\\dagger [ N^{-1} r + N^{-1/2} \\omega_r ] omega_n = ( realisation_switch * ( 1.0 * np.random.randn(*resid_chunk.shape) + 1.0j * np.random.randn(*resid_chunk.shape) ) / np.sqrt(2.0) ) # Separate complex part of RHS into real and imaginary parts, and apply # the real and imaginary parts of the projection operator separately. # This is necessary to get a real RHS vector y = ( (resid_chunk * inv_noise_var_chunk) + (omega_n * np.sqrt(inv_noise_var_chunk)) ).flatten() b = amp_prior_std * (proj.T.real @ y.real + proj.T.imag @ y.imag) # Reduce (sum) operation on b linear_rhs = np.zeros((1,), dtype=b.dtype) # dummy data for non-root workers if myid == 0: linear_rhs = np.zeros_like(b) if comm is not None: comm.Reduce(b, linear_rhs, op=MPI_SUM, root=0) else: linear_rhs = b # (Term 2): \\omega_a if myid == 0: linear_rhs += realisation_switch * np.random.randn(nsrcs) # real vector return linear_op, linear_rhs","title":"Point source sampler (ptsrc_sampler)"},{"location":"ptsrc_sampler/#point-source-sampler-ptsrc_sampler","text":"","title":"Point source sampler (ptsrc_sampler)"},{"location":"ptsrc_sampler/#hydra.ptsrc_sampler.calc_proj_operator","text":"Calculate a visibility vector for each point source, as a function of frequency, time, and baseline. This is the projection operator from point source amplitude to visibilities. Gains are not included. Parameters: Name Type Description Default ra, dec (array_like RA and Dec of each source, in radians. required fluxes array_like Flux for each point source as a function of frequency. required ant_pos dict Dictionary of antenna positions, [x, y, z], in m. The keys should be the numerical antenna IDs. required antpairs list of tuple List of tuples containing pairs of antenna IDs, one for each baseline. required freqs array_like Frequencies, in MHz. required times array_like LSTs, in radians. required beams list of UVBeam List of UVBeam objects, one for each antenna. required latitude float Latitude of the observing site, in radians. -0.5361913261514378 Returns: Name Type Description vis_proj_operator array_like The projection operator from source amplitudes to visibilities, from calc_proj_operator . This is an array of the visibility values for each source. Source code in hydra/ptsrc_sampler.py def calc_proj_operator( ra, dec, fluxes, ant_pos, antpairs, freqs, times, beams, latitude=-0.5361913261514378, ): \"\"\" Calculate a visibility vector for each point source, as a function of frequency, time, and baseline. This is the projection operator from point source amplitude to visibilities. Gains are not included. Parameters: ra, dec (array_like): RA and Dec of each source, in radians. fluxes (array_like): Flux for each point source as a function of frequency. ant_pos (dict): Dictionary of antenna positions, [x, y, z], in m. The keys should be the numerical antenna IDs. antpairs (list of tuple): List of tuples containing pairs of antenna IDs, one for each baseline. freqs (array_like): Frequencies, in MHz. times (array_like): LSTs, in radians. beams (list of UVBeam): List of UVBeam objects, one for each antenna. latitude (float): Latitude of the observing site, in radians. Returns: vis_proj_operator (array_like): The projection operator from source amplitudes to visibilities, from `calc_proj_operator`. This is an array of the visibility values for each source. \"\"\" Nptsrc = ra.size Nants = len(ant_pos) Nvis = len(antpairs) # Empty array of per-point source visibilities vis_ptsrc = np.zeros((Nvis, freqs.size, times.size, Nptsrc), dtype=np.complex128) # Get visibility for each point source # Returns shape (NFREQS, NTIMES, NANTS, NANTS, NSRCS) vis = simulate_vis_per_source( ants=ant_pos, fluxes=fluxes, ra=ra, dec=dec, freqs=freqs * 1e6, lsts=times, beams=beams, polarized=False, precision=2, latitude=latitude, use_feed=\"x\", ) # Allocate computed visibilities to only available baselines (saves memory) ants = list(ant_pos.keys()) for i, bl in enumerate(antpairs): idx1 = ants.index(bl[0]) idx2 = ants.index(bl[1]) vis_ptsrc[i, :, :, :] = vis[:, :, idx1, idx2, :] return vis_ptsrc","title":"calc_proj_operator"},{"location":"ptsrc_sampler/#hydra.ptsrc_sampler.precompute_mpi","text":"Precompute the projection operator and matrix operator in parallel. The projection operator is computed in chunks in time and frequency. The overall matrix operator can be computed by summing the matrix operator for the time and frequency chunks. Source code in hydra/ptsrc_sampler.py def precompute_mpi( comm, ants, antpairs, freq_chunk, time_chunk, proj_chunk, data_chunk, inv_noise_var_chunk, gain_chunk, amp_prior_std, realisation=True, ): \"\"\" Precompute the projection operator and matrix operator in parallel. The projection operator is computed in chunks in time and frequency. The overall matrix operator can be computed by summing the matrix operator for the time and frequency chunks. \"\"\" # Make sure ants is an array ants = np.atleast_1d(ants) if comm is not None: myid = comm.Get_rank() else: myid = 0 # Check input dimensions assert data_chunk.shape == (len(antpairs), freq_chunk.size, time_chunk.size) assert data_chunk.shape == inv_noise_var_chunk.shape proj = proj_chunk.copy() # make a copy so we don't alter the original proj! # FIXME: Check for unused args! # Apply gains to projection operator for k, bl in enumerate(antpairs): ant1, ant2 = bl i1 = np.where(ants == ant1)[0][0] i2 = np.where(ants == ant2)[0][0] proj[k, :, :, :] *= ( gain_chunk[i1, :, :, np.newaxis] * gain_chunk[i2, :, :, np.newaxis].conj() ) # (2) Precompute linear system operator nsrcs = proj.shape[-1] my_linear_op = np.zeros((nsrcs, nsrcs), dtype=proj.real.dtype) # inv_noise_var has shape (Nbls, Nfreqs, Ntimes) v_re = (proj.real * np.sqrt(inv_noise_var_chunk[..., np.newaxis])).reshape( (-1, nsrcs) ) v_im = (proj.imag * np.sqrt(inv_noise_var_chunk[..., np.newaxis])).reshape( ((-1, nsrcs)) ) # Treat real and imaginary separately, and get copies, to massively # speed-up the matrix multiplication! my_linear_op[:, :] = v_re.T @ v_re + v_im.T @ v_im del v_re, v_im # Do Reduce (sum) operation to get total operator on root node linear_op = np.zeros( (1, 1), dtype=my_linear_op.dtype ) # dummy data for non-root workers if myid == 0: linear_op = np.zeros_like(my_linear_op) if comm is not None: comm.Reduce(my_linear_op, linear_op, op=MPI_SUM, root=0) else: linear_op = my_linear_op # Include prior and identity terms to finish constructing LHS operator on root worker if myid == 0: linear_op = np.eye(linear_op.shape[0]) + np.diag( amp_prior_std ) @ linear_op @ np.diag(amp_prior_std) # (3) Calculate linear system RHS proj = proj.reshape((-1, nsrcs)) realisation_switch = ( 1.0 if realisation else 0.0 ) # Turn random realisations on or off # Calculate residual of data vs fiducial model (residual from amplitudes = 1) # (proj now includes gains) resid_chunk = data_chunk.copy() - ( proj.reshape((-1, nsrcs)) @ np.ones_like(amp_prior_std) ).reshape(data_chunk.shape) # (Terms 1+3): S^1/2 A^\\dagger [ N^{-1} r + N^{-1/2} \\omega_r ] omega_n = ( realisation_switch * ( 1.0 * np.random.randn(*resid_chunk.shape) + 1.0j * np.random.randn(*resid_chunk.shape) ) / np.sqrt(2.0) ) # Separate complex part of RHS into real and imaginary parts, and apply # the real and imaginary parts of the projection operator separately. # This is necessary to get a real RHS vector y = ( (resid_chunk * inv_noise_var_chunk) + (omega_n * np.sqrt(inv_noise_var_chunk)) ).flatten() b = amp_prior_std * (proj.T.real @ y.real + proj.T.imag @ y.imag) # Reduce (sum) operation on b linear_rhs = np.zeros((1,), dtype=b.dtype) # dummy data for non-root workers if myid == 0: linear_rhs = np.zeros_like(b) if comm is not None: comm.Reduce(b, linear_rhs, op=MPI_SUM, root=0) else: linear_rhs = b # (Term 2): \\omega_a if myid == 0: linear_rhs += realisation_switch * np.random.randn(nsrcs) # real vector return linear_op, linear_rhs","title":"precompute_mpi"},{"location":"region_sampler/","text":"Region sampler ( region_sampler ) calc_proj_operator(region_pixel_ra, region_pixel_dec, region_fluxes, region_idxs, ant_pos, antpairs, freqs, times, beams, latitude=-0.5361913261514378) Calculate a visibility vector for each point source, as a function of frequency, time, and baseline. This is the projection operator from point source amplitude to visibilities. Gains are not included. Parameters: Name Type Description Default region_pixel_ra, region_pixel_dec (list of array_like RA and Dec of each pixel (axcross all regions), in radians. required region_fluxes array_like Flux for each pixel (across all regions), as a function of frequency. required region_idxs list of array_like List of pixel indices for each region. required ant_pos dict Dictionary of antenna positions, [x, y, z], in m. The keys should be the numerical antenna IDs. required antpairs list of tuple List of tuples containing pairs of antenna IDs, one for each baseline. required freqs array_like Frequencies, in MHz. required times array_like LSTs, in radians. required beams list of UVBeam List of UVBeam objects, one for each antenna. required latitude float Latitude of the observing site, in radians. -0.5361913261514378 Returns: Name Type Description proj_operator array_like The projection operator from region amplitudes to visibilities. This is an array of the visibility values for each region. Source code in hydra/region_sampler.py def calc_proj_operator( region_pixel_ra, region_pixel_dec, region_fluxes, region_idxs, ant_pos, antpairs, freqs, times, beams, latitude=-0.5361913261514378, ): \"\"\" Calculate a visibility vector for each point source, as a function of frequency, time, and baseline. This is the projection operator from point source amplitude to visibilities. Gains are not included. Parameters: region_pixel_ra, region_pixel_dec (list of array_like): RA and Dec of each pixel (axcross all regions), in radians. region_fluxes (array_like): Flux for each pixel (across all regions), as a function of frequency. region_idxs (list of array_like): List of pixel indices for each region. ant_pos (dict): Dictionary of antenna positions, [x, y, z], in m. The keys should be the numerical antenna IDs. antpairs (list of tuple): List of tuples containing pairs of antenna IDs, one for each baseline. freqs (array_like): Frequencies, in MHz. times (array_like): LSTs, in radians. beams (list of UVBeam): List of UVBeam objects, one for each antenna. latitude (float): Latitude of the observing site, in radians. Returns: proj_operator (array_like): The projection operator from region amplitudes to visibilities. This is an array of the visibility values for each region. \"\"\" Nregions = len(region_idxs) Nants = len(ant_pos) Nvis = len(antpairs) ants = list(ant_pos.keys()) # Empty array of per-point source visibilities vis_region = np.zeros((Nvis, freqs.size, times.size, Nregions), dtype=np.complex128) # Get visibility for each region for j in range(Nregions): # Returns shape (NFREQS, NTIMES, NANTS, NANTS) vis = simulate_vis( ants=ant_pos, fluxes=region_fluxes[region_idxs[j], :], ra=region_pixel_ra[region_idxs[j]], dec=region_pixel_dec[region_idxs[j]], freqs=freqs * 1e6, lsts=times, beams=beams, polarized=False, precision=2, latitude=latitude, use_feed=\"x\", ) # Allocate computed visibilities to only available baselines (saves memory) for i, bl in enumerate(antpairs): idx1 = ants.index(bl[0]) idx2 = ants.index(bl[1]) vis_region[i, :, :, j] = vis[:, :, idx1, idx2] return vis_region get_diffuse_sky_model_pixels(freqs, nside=32, sky_model='gsm2016') Returns arrays of the pixel RA, Dec locations and per-pixel frequency spectra from a given sky model. By default this is GSM, as implemented in pygdsm . Parameters: Name Type Description Default freqs array_like Frequencies, in MHz. required nside int Healpix nside to use when constructing the sky model. 32 sky_model str Which sky modle to use, from pyGDSM. One of: 'gsm2008', 'gsm2016', 'haslam', 'lfss'. 'gsm2016' Returns: Name Type Description ra, dec (array_like): ICRS RA and Dec locations of each pixel. RA range is (0, 360) deg, Dec range is (-90, +90) deg, but they are returned in radians. sky_maps array_like The frequency spectrum in each pixel. Shape is (Npix, Nfreq) . Source code in hydra/region_sampler.py def get_diffuse_sky_model_pixels(freqs, nside=32, sky_model=\"gsm2016\"): \"\"\" Returns arrays of the pixel RA, Dec locations and per-pixel frequency spectra from a given sky model. By default this is GSM, as implemented in `pygdsm`. Parameters: freqs (array_like): Frequencies, in MHz. nside (int): Healpix nside to use when constructing the sky model. sky_model (str): Which sky modle to use, from pyGDSM. One of: 'gsm2008', 'gsm2016', 'haslam', 'lfss'. Returns: ra, dec (array_like): ICRS RA and Dec locations of each pixel. RA range is (0, 360) deg, Dec range is (-90, +90) deg, but they are returned in radians. sky_maps (array_like): The frequency spectrum in each pixel. Shape is `(Npix, Nfreq)`. \"\"\" # Get expected frequency units freqs_MHz = freqs # Initialise sky model and extract data cube assert sky_model in [ \"gsm2008\", \"gsm2016\", \"haslam\", \"lfsm\", ], \"Available sky models: 'gsm2008', 'gsm2016', 'haslam', 'lfsm'\" if sky_model == \"gsm2008\": model = pygdsm.GlobalSkyModel(freq_unit=\"MHz\", include_cmb=False) if sky_model == \"gsm2016\": try: model = pygdsm.GlobalSkyModel2016(freq_unit=\"MHz\", include_cmb=False) except(AttributeError): # Different versions of pygdsm changed the API model = pygdsm.GlobalSkyModel16(freq_unit=\"MHz\", include_cmb=False) if sky_model == \"haslam\": model = pygdsm.HaslamSkyModel(freq_unit=\"MHz\", include_cmb=False) if sky_model == \"lfsm\": model = pygdsm.LowFrequencySkyModel(freq_unit=\"MHz\", include_cmb=False) model.generate(freqs_MHz) sky_maps = model.generated_map_data # (Nfreqs, Npix), should be in Kelvin # Must change nside to make compute practical nside_gsm = hp.npix2nside(sky_maps[0].size) sky_maps = hp.ud_grade(sky_maps, nside_out=nside) # Convert from Kelvin to Jy/sr equiv = u.brightness_temperature(freqs_MHz * u.MHz, beam_area=1 * u.sr) Ksr_per_Jy = ((1 * u.Jy).to(u.K, equivalencies=equiv) * u.sr / u.Jy).value for i in range(Ksr_per_Jy.size): sky_maps[i] /= Ksr_per_Jy[i] # converts K to Jy/sr # Get pixel RA/Dec coords (assumes Galactic coords for sky map data) idxs = np.arange(sky_maps[0].size) pix_lon, pix_lat = hp.pix2ang(nside, idxs, lonlat=True) gal_coords = Galactic(l=pix_lon * u.deg, b=pix_lat * u.deg) icrs_frame = ICRS() eq_coords = gal_coords.transform_to(icrs_frame) ra = eq_coords.ra.rad dec = eq_coords.dec.rad # Returns list of pixels with spectra as effective point sources return ra, dec, sky_maps.T segmented_diffuse_sky_model_pixels(ra, dec, sky_maps, freqs, nregions, smoothing_fwhm=None) Returns a list of pixel indices for each region in a diffuse sky map. This function currently uses a crude spectral index measurement to segment the map into regions with roughly equal numbers of pixels. Smoothing can be used to reduce sharp edges. The regions can be disconnected. Parameters: Name Type Description Default ra, dec (array_like ICRS RA and Dec locations of each pixel. required sky_maps array_like The frequency spectrum in each pixel. required freqs array_like Frequencies, in MHz. required nregions int The number of regions of roughly equal numbers of pixels to segment the sky map into. required smoothing_fwhm float Smoothing FWHM (in degrees) to apply to the segmented map in order to reduce sharp edges. The smoothing is applied to a map of region indices. It is then re-segmented, which can result in a slight reduction in the number of segments due to round-off of region indices. None Returns: Name Type Description idxs list of array_like List of arrays, with each array containing the array indices of the pixels that belong to each region. Source code in hydra/region_sampler.py def segmented_diffuse_sky_model_pixels( ra, dec, sky_maps, freqs, nregions, smoothing_fwhm=None ): \"\"\" Returns a list of pixel indices for each region in a diffuse sky map. This function currently uses a crude spectral index measurement to segment the map into regions with roughly equal numbers of pixels. Smoothing can be used to reduce sharp edges. The regions can be disconnected. Parameters: ra, dec (array_like): ICRS RA and Dec locations of each pixel. sky_maps (array_like): The frequency spectrum in each pixel. freqs (array_like): Frequencies, in MHz. nregions (int): The number of regions of roughly equal numbers of pixels to segment the sky map into. smoothing_fwhm (float): Smoothing FWHM (in degrees) to apply to the segmented map in order to reduce sharp edges. The smoothing is applied to a map of region indices. It is then re-segmented, which can result in a slight reduction in the number of segments due to round-off of region indices. Returns: idxs (list of array_like): List of arrays, with each array containing the array indices of the pixels that belong to each region. \"\"\" # Crude spectral index map beta = np.log(sky_maps[:, 0] / sky_maps[:, 1]) / np.log(freqs[0] / freqs[1]) # Sort spectral index map and break up into ~equal-sized segments beta_sorted = np.sort(beta) bounds = beta_sorted[:: beta_sorted.size // nregions] # Loop over regions and select pixels belonging to each region regions = np.zeros(beta.size, dtype=int) for i in range(bounds.size - 1): # These have >= and <= to ensure that all pixels belong somewhere idxs = np.where(np.logical_and(beta >= bounds[i], beta <= bounds[i + 1])) regions[idxs] = i # Apply smoothing and then re-segment if smoothing_fwhm is not None: regions_smoothed = hp.smoothing(regions, fwhm=np.deg2rad(smoothing_fwhm)) regions_final = regions_smoothed.astype(int) else: regions_final = regions # Create list of indices unique_idxs = np.sort(np.unique(regions_final)) idx_list = [np.where(regions_final == i)[0] for i in unique_idxs] return idx_list","title":"Region sampler (region_sampler)"},{"location":"region_sampler/#region-sampler-region_sampler","text":"","title":"Region sampler (region_sampler)"},{"location":"region_sampler/#hydra.region_sampler.calc_proj_operator","text":"Calculate a visibility vector for each point source, as a function of frequency, time, and baseline. This is the projection operator from point source amplitude to visibilities. Gains are not included. Parameters: Name Type Description Default region_pixel_ra, region_pixel_dec (list of array_like RA and Dec of each pixel (axcross all regions), in radians. required region_fluxes array_like Flux for each pixel (across all regions), as a function of frequency. required region_idxs list of array_like List of pixel indices for each region. required ant_pos dict Dictionary of antenna positions, [x, y, z], in m. The keys should be the numerical antenna IDs. required antpairs list of tuple List of tuples containing pairs of antenna IDs, one for each baseline. required freqs array_like Frequencies, in MHz. required times array_like LSTs, in radians. required beams list of UVBeam List of UVBeam objects, one for each antenna. required latitude float Latitude of the observing site, in radians. -0.5361913261514378 Returns: Name Type Description proj_operator array_like The projection operator from region amplitudes to visibilities. This is an array of the visibility values for each region. Source code in hydra/region_sampler.py def calc_proj_operator( region_pixel_ra, region_pixel_dec, region_fluxes, region_idxs, ant_pos, antpairs, freqs, times, beams, latitude=-0.5361913261514378, ): \"\"\" Calculate a visibility vector for each point source, as a function of frequency, time, and baseline. This is the projection operator from point source amplitude to visibilities. Gains are not included. Parameters: region_pixel_ra, region_pixel_dec (list of array_like): RA and Dec of each pixel (axcross all regions), in radians. region_fluxes (array_like): Flux for each pixel (across all regions), as a function of frequency. region_idxs (list of array_like): List of pixel indices for each region. ant_pos (dict): Dictionary of antenna positions, [x, y, z], in m. The keys should be the numerical antenna IDs. antpairs (list of tuple): List of tuples containing pairs of antenna IDs, one for each baseline. freqs (array_like): Frequencies, in MHz. times (array_like): LSTs, in radians. beams (list of UVBeam): List of UVBeam objects, one for each antenna. latitude (float): Latitude of the observing site, in radians. Returns: proj_operator (array_like): The projection operator from region amplitudes to visibilities. This is an array of the visibility values for each region. \"\"\" Nregions = len(region_idxs) Nants = len(ant_pos) Nvis = len(antpairs) ants = list(ant_pos.keys()) # Empty array of per-point source visibilities vis_region = np.zeros((Nvis, freqs.size, times.size, Nregions), dtype=np.complex128) # Get visibility for each region for j in range(Nregions): # Returns shape (NFREQS, NTIMES, NANTS, NANTS) vis = simulate_vis( ants=ant_pos, fluxes=region_fluxes[region_idxs[j], :], ra=region_pixel_ra[region_idxs[j]], dec=region_pixel_dec[region_idxs[j]], freqs=freqs * 1e6, lsts=times, beams=beams, polarized=False, precision=2, latitude=latitude, use_feed=\"x\", ) # Allocate computed visibilities to only available baselines (saves memory) for i, bl in enumerate(antpairs): idx1 = ants.index(bl[0]) idx2 = ants.index(bl[1]) vis_region[i, :, :, j] = vis[:, :, idx1, idx2] return vis_region","title":"calc_proj_operator"},{"location":"region_sampler/#hydra.region_sampler.get_diffuse_sky_model_pixels","text":"Returns arrays of the pixel RA, Dec locations and per-pixel frequency spectra from a given sky model. By default this is GSM, as implemented in pygdsm . Parameters: Name Type Description Default freqs array_like Frequencies, in MHz. required nside int Healpix nside to use when constructing the sky model. 32 sky_model str Which sky modle to use, from pyGDSM. One of: 'gsm2008', 'gsm2016', 'haslam', 'lfss'. 'gsm2016' Returns: Name Type Description ra, dec (array_like): ICRS RA and Dec locations of each pixel. RA range is (0, 360) deg, Dec range is (-90, +90) deg, but they are returned in radians. sky_maps array_like The frequency spectrum in each pixel. Shape is (Npix, Nfreq) . Source code in hydra/region_sampler.py def get_diffuse_sky_model_pixels(freqs, nside=32, sky_model=\"gsm2016\"): \"\"\" Returns arrays of the pixel RA, Dec locations and per-pixel frequency spectra from a given sky model. By default this is GSM, as implemented in `pygdsm`. Parameters: freqs (array_like): Frequencies, in MHz. nside (int): Healpix nside to use when constructing the sky model. sky_model (str): Which sky modle to use, from pyGDSM. One of: 'gsm2008', 'gsm2016', 'haslam', 'lfss'. Returns: ra, dec (array_like): ICRS RA and Dec locations of each pixel. RA range is (0, 360) deg, Dec range is (-90, +90) deg, but they are returned in radians. sky_maps (array_like): The frequency spectrum in each pixel. Shape is `(Npix, Nfreq)`. \"\"\" # Get expected frequency units freqs_MHz = freqs # Initialise sky model and extract data cube assert sky_model in [ \"gsm2008\", \"gsm2016\", \"haslam\", \"lfsm\", ], \"Available sky models: 'gsm2008', 'gsm2016', 'haslam', 'lfsm'\" if sky_model == \"gsm2008\": model = pygdsm.GlobalSkyModel(freq_unit=\"MHz\", include_cmb=False) if sky_model == \"gsm2016\": try: model = pygdsm.GlobalSkyModel2016(freq_unit=\"MHz\", include_cmb=False) except(AttributeError): # Different versions of pygdsm changed the API model = pygdsm.GlobalSkyModel16(freq_unit=\"MHz\", include_cmb=False) if sky_model == \"haslam\": model = pygdsm.HaslamSkyModel(freq_unit=\"MHz\", include_cmb=False) if sky_model == \"lfsm\": model = pygdsm.LowFrequencySkyModel(freq_unit=\"MHz\", include_cmb=False) model.generate(freqs_MHz) sky_maps = model.generated_map_data # (Nfreqs, Npix), should be in Kelvin # Must change nside to make compute practical nside_gsm = hp.npix2nside(sky_maps[0].size) sky_maps = hp.ud_grade(sky_maps, nside_out=nside) # Convert from Kelvin to Jy/sr equiv = u.brightness_temperature(freqs_MHz * u.MHz, beam_area=1 * u.sr) Ksr_per_Jy = ((1 * u.Jy).to(u.K, equivalencies=equiv) * u.sr / u.Jy).value for i in range(Ksr_per_Jy.size): sky_maps[i] /= Ksr_per_Jy[i] # converts K to Jy/sr # Get pixel RA/Dec coords (assumes Galactic coords for sky map data) idxs = np.arange(sky_maps[0].size) pix_lon, pix_lat = hp.pix2ang(nside, idxs, lonlat=True) gal_coords = Galactic(l=pix_lon * u.deg, b=pix_lat * u.deg) icrs_frame = ICRS() eq_coords = gal_coords.transform_to(icrs_frame) ra = eq_coords.ra.rad dec = eq_coords.dec.rad # Returns list of pixels with spectra as effective point sources return ra, dec, sky_maps.T","title":"get_diffuse_sky_model_pixels"},{"location":"region_sampler/#hydra.region_sampler.segmented_diffuse_sky_model_pixels","text":"Returns a list of pixel indices for each region in a diffuse sky map. This function currently uses a crude spectral index measurement to segment the map into regions with roughly equal numbers of pixels. Smoothing can be used to reduce sharp edges. The regions can be disconnected. Parameters: Name Type Description Default ra, dec (array_like ICRS RA and Dec locations of each pixel. required sky_maps array_like The frequency spectrum in each pixel. required freqs array_like Frequencies, in MHz. required nregions int The number of regions of roughly equal numbers of pixels to segment the sky map into. required smoothing_fwhm float Smoothing FWHM (in degrees) to apply to the segmented map in order to reduce sharp edges. The smoothing is applied to a map of region indices. It is then re-segmented, which can result in a slight reduction in the number of segments due to round-off of region indices. None Returns: Name Type Description idxs list of array_like List of arrays, with each array containing the array indices of the pixels that belong to each region. Source code in hydra/region_sampler.py def segmented_diffuse_sky_model_pixels( ra, dec, sky_maps, freqs, nregions, smoothing_fwhm=None ): \"\"\" Returns a list of pixel indices for each region in a diffuse sky map. This function currently uses a crude spectral index measurement to segment the map into regions with roughly equal numbers of pixels. Smoothing can be used to reduce sharp edges. The regions can be disconnected. Parameters: ra, dec (array_like): ICRS RA and Dec locations of each pixel. sky_maps (array_like): The frequency spectrum in each pixel. freqs (array_like): Frequencies, in MHz. nregions (int): The number of regions of roughly equal numbers of pixels to segment the sky map into. smoothing_fwhm (float): Smoothing FWHM (in degrees) to apply to the segmented map in order to reduce sharp edges. The smoothing is applied to a map of region indices. It is then re-segmented, which can result in a slight reduction in the number of segments due to round-off of region indices. Returns: idxs (list of array_like): List of arrays, with each array containing the array indices of the pixels that belong to each region. \"\"\" # Crude spectral index map beta = np.log(sky_maps[:, 0] / sky_maps[:, 1]) / np.log(freqs[0] / freqs[1]) # Sort spectral index map and break up into ~equal-sized segments beta_sorted = np.sort(beta) bounds = beta_sorted[:: beta_sorted.size // nregions] # Loop over regions and select pixels belonging to each region regions = np.zeros(beta.size, dtype=int) for i in range(bounds.size - 1): # These have >= and <= to ensure that all pixels belong somewhere idxs = np.where(np.logical_and(beta >= bounds[i], beta <= bounds[i + 1])) regions[idxs] = i # Apply smoothing and then re-segment if smoothing_fwhm is not None: regions_smoothed = hp.smoothing(regions, fwhm=np.deg2rad(smoothing_fwhm)) regions_final = regions_smoothed.astype(int) else: regions_final = regions # Create list of indices unique_idxs = np.sort(np.unique(regions_final)) idx_list = [np.where(regions_final == i)[0] for i in unique_idxs] return idx_list","title":"segmented_diffuse_sky_model_pixels"},{"location":"sh_sampler/","text":"Spherical harmonic sampler ( sh_sampler ) alms2healpy(alms, lmax) Takes a real array split as [real, imag] (without the m=0 modes imag-part) and turns it into a complex array of alms (positive modes only) ordered as in HEALpy. Parameters: Name Type Description Default alms array_like Array of zeros except for the specified mode. The array represents all positive (+m) modes including zero and has double length, as real and imaginary values are split. The first half is the real values. required Returns: Name Type Description healpy_modes array_like Array of zeros except for the specified mode. The array represents all positive (+m) modes including zeroth modes. Source code in hydra/sh_sampler.py def alms2healpy(alms, lmax): \"\"\" Takes a real array split as [real, imag] (without the m=0 modes imag-part) and turns it into a complex array of alms (positive modes only) ordered as in HEALpy. Parameters: alms (array_like): Array of zeros except for the specified mode. The array represents all positive (+m) modes including zero and has double length, as real and imaginary values are split. The first half is the real values. Returns: healpy_modes (array_like): Array of zeros except for the specified mode. The array represents all positive (+m) modes including zeroth modes. \"\"\" if len(alms.shape) == 1: # Combine real and imaginary parts into alm format expected by healpy real_imag_split_index = int((np.size(alms) + (lmax + 1)) / 2) real = alms[:real_imag_split_index] add_imag_m0_modes = np.zeros(lmax + 1) # add m=0 imag. modes back in imag = np.concatenate((add_imag_m0_modes, alms[real_imag_split_index:])) healpy_modes = real + 1.0j * imag return healpy_modes elif len(alms.shape) == 2: # Handle 2D array case (loop over entries) with a recursion return np.array([alms2healpy(modes, lmax) for modes in alms]) else: raise ValueError(\"alms array must either have shape (Nmodes,) or (Nmaps, Nmodes)\") apply_lhs_no_rot(a_cr, inv_noise_var, inv_prior_var, vis_response) Apply LHS operator of linear system to an input vector. Source code in hydra/sh_sampler.py def apply_lhs_no_rot(a_cr, inv_noise_var, inv_prior_var, vis_response): \"\"\" Apply LHS operator of linear system to an input vector. \"\"\" real_noise_term = ( vis_response.real.T @ (inv_noise_var[:, np.newaxis] * vis_response.real) @ a_cr ) imag_noise_term = ( vis_response.imag.T @ (inv_noise_var[:, np.newaxis] * vis_response.imag) @ a_cr ) signal_term = inv_prior_var * a_cr left_hand_side = real_noise_term + imag_noise_term + signal_term return left_hand_side apply_lhs_no_rot_mpi(comm, a_cr, inv_noise_var, inv_prior_var, vis_response) Apply LHS operator of linear system to an input vector that has been split into chunks between MPI workers. Source code in hydra/sh_sampler.py def apply_lhs_no_rot_mpi(comm, a_cr, inv_noise_var, inv_prior_var, vis_response): \"\"\" Apply LHS operator of linear system to an input vector that has been split into chunks between MPI workers. \"\"\" if comm is not None: myid = comm.Get_rank() else: myid = 0 # Synchronise a_cr across all workers if myid != 0: a_cr *= 0. if comm is not None: comm.Bcast(a_cr, root=0) # Calculate noise terms for this rank my_tot_noise_term = ( vis_response.real.T @ (inv_noise_var.flatten()[:, np.newaxis] * vis_response.real) @ a_cr + vis_response.imag.T @ (inv_noise_var.flatten()[:, np.newaxis] * vis_response.imag) @ a_cr ) # Do Reduce (sum) operation to get total operator on root node tot_noise_term = np.zeros( (1,), dtype=my_tot_noise_term.dtype ) # dummy data for non-root workers if myid == 0: tot_noise_term = np.zeros_like(my_tot_noise_term) if comm is not None: comm.Reduce(my_tot_noise_term, tot_noise_term, op=MPI_SUM, root=0) else: tot_noise_term = my_tot_noise_term # Return result (only root worker has correct result) if myid == 0: signal_term = inv_prior_var * a_cr return tot_noise_term + signal_term else: return np.zeros_like(a_cr) construct_rhs_no_rot(data, inv_noise_var, inv_prior_var, omega_0, omega_1, a_0, vis_response) Construct RHS of linear system. Source code in hydra/sh_sampler.py def construct_rhs_no_rot( data, inv_noise_var, inv_prior_var, omega_0, omega_1, a_0, vis_response ): \"\"\" Construct RHS of linear system. \"\"\" real_data_term = vis_response.real.T @ ( inv_noise_var * data.real + np.sqrt(inv_noise_var) * omega_1.real ) imag_data_term = vis_response.imag.T @ ( inv_noise_var * data.imag + np.sqrt(inv_noise_var) * omega_1.imag ) prior_term = inv_prior_var * a_0 + np.sqrt(inv_prior_var) * omega_0 right_hand_side = real_data_term + imag_data_term + prior_term return right_hand_side construct_rhs_no_rot_mpi(comm, data, inv_noise_var, inv_prior_var, omega_a, omega_n, a_0, vis_response) Construct RHS of linear system from data split across multiple MPI workers. Source code in hydra/sh_sampler.py def construct_rhs_no_rot_mpi( comm, data, inv_noise_var, inv_prior_var, omega_a, omega_n, a_0, vis_response ): \"\"\" Construct RHS of linear system from data split across multiple MPI workers. \"\"\" if comm is not None: myid = comm.Get_rank() else: myid = 0 # Synchronise omega_a across all workers if myid != 0: omega_a *= 0. if comm is not None: comm.Bcast(omega_a, root=0) # Calculate data terms my_data_term = vis_response.real.T @ ( (inv_noise_var * data.real).flatten() + np.sqrt(inv_noise_var).flatten() * omega_n.real.flatten() ) + vis_response.imag.T @ ( (inv_noise_var * data.imag).flatten() + np.sqrt(inv_noise_var).flatten() * omega_n.imag.flatten() ) # Do Reduce (sum) operation to get total operator on root node data_term = np.zeros( (1,), dtype=my_data_term.dtype ) # dummy data for non-root workers if myid == 0: data_term = np.zeros_like(my_data_term) if comm is not None: comm.Reduce(my_data_term, data_term, op=MPI_SUM, root=0) comm.barrier() else: data_term = my_data_term # Return result (only root worker has correct result) if myid == 0: return data_term + inv_prior_var * a_0 + np.sqrt(inv_prior_var) * omega_a else: return np.zeros_like(a_0) get_alms_from_gsm(freq, lmax, nside=64, resolution='low', output_model=False, output_map=False) Generate a real array split as [real, imag] (without the m=0 modes imag-part) from gsm 2016 (https://github.com/telegraphic/pygdsm) freqs (float or array_like): Frequency (in MHz) for which to return GSM model lmax (int): Maximum ell value for alms nside (int): The nside to upgrade/downgrade the map to. Default is nside=64. resolution (str): if \"low/lo/l\": nside = 64 (default) if \"hi/high/h\": nside = 1024 output_model (bool): If output_model=True: Outputs model generated from the GSM data. If output_model=False (default): no model output. output_map (bool): If output_map=True: Outputs map generated from the GSM data. If output_map=False (default): no map output. Returns: Name Type Description alms array_like Array of zeros except for the specified mode. The array represents all positive (+m) modes including zero and has double length, as real and imaginary values are split. The first half is the real values. gsm_2016 PyGDSM 2016 model If output_model=True: Outputs model generated from the GSM data. If output_model=False (default): no model output. gsm_map healpy map If output_map=True: Outputs map generated from the GSM data. If output_map=False (default): no map output. Source code in hydra/sh_sampler.py def get_alms_from_gsm( freq, lmax, nside=64, resolution=\"low\", output_model=False, output_map=False ): \"\"\" Generate a real array split as [real, imag] (without the m=0 modes imag-part) from gsm 2016 (https://github.com/telegraphic/pygdsm) Parameters: freqs (float or array_like): Frequency (in MHz) for which to return GSM model lmax (int): Maximum ell value for alms nside (int): The nside to upgrade/downgrade the map to. Default is nside=64. resolution (str): if \"low/lo/l\": nside = 64 (default) if \"hi/high/h\": nside = 1024 output_model (bool): If output_model=True: Outputs model generated from the GSM data. If output_model=False (default): no model output. output_map (bool): If output_map=True: Outputs map generated from the GSM data. If output_map=False (default): no map output. Returns: alms (array_like): Array of zeros except for the specified mode. The array represents all positive (+m) modes including zero and has double length, as real and imaginary values are split. The first half is the real values. gsm_2016 (PyGDSM 2016 model): If output_model=True: Outputs model generated from the GSM data. If output_model=False (default): no model output. gsm_map (healpy map): If output_map=True: Outputs map generated from the GSM data. If output_map=False (default): no map output. \"\"\" return healpy2alms( get_healpy_from_gsm(freq, lmax, nside, resolution, output_model, output_map) ) get_em_ell_idx(lmax) With (m,l) ordering! Source code in hydra/sh_sampler.py def get_em_ell_idx(lmax): \"\"\" With (m,l) ordering! \"\"\" ells_list = np.arange(0, lmax + 1) em_real = np.arange(0, lmax + 1) em_imag = np.arange(1, lmax + 1) # ylabel = [] # First append all real (l,m) values Nreal = 0 i = 0 idx = [] ems = [] ells = [] for em in em_real: for ell in ells_list: if ell >= em: idx.append(i) ems.append(em) ells.append(ell) Nreal += 1 i += 1 # Then all imaginary -- note: no m=0 modes! Nimag = 0 for em in em_imag: for ell in ells_list: if ell >= em: idx.append(i) ems.append(em) ells.append(ell) Nimag += 1 i += 1 return ems, ells, idx get_healpy_from_gsm(freq, lmax, nside=64, resolution='low', output_model=False, output_map=False) Generate an array of alms (HEALpy ordered) from gsm 2016 (https://github.com/telegraphic/pygdsm) Parameters: Name Type Description Default freqs array_like Frequency (in MHz) for which to return GSM model. required lmax int Maximum ell value for alms required nside int The nside to upgrade/downgrade the map to. Default is nside=64. 64 resolution str if \"low/lo/l\": The GSM nside = 64 (default) if \"hi/high/h\": The GSM nside = 1024 'low' output_model bool If output_model=True: Outputs model generated from the GSM data. If output_model=False (default): no model output. False output_map bool If output_map=True: Outputs map generated from the GSM data. If output_map=False (default): no map output. False Returns: Name Type Description healpy_modes array_like Complex array of alms with same size and ordering as in healpy (m,l) gsm_2016 PyGDSM 2016 model If output_model=True: Outputs model generated from the GSM data. If output_model=False (default): no model output. gsm_map healpy map If output_map=True: Outputs map generated from the GSM data. If output_map=False (default): no map output. Source code in hydra/sh_sampler.py def get_healpy_from_gsm( freq, lmax, nside=64, resolution=\"low\", output_model=False, output_map=False ): \"\"\" Generate an array of alms (HEALpy ordered) from gsm 2016 (https://github.com/telegraphic/pygdsm) Parameters: freqs (array_like): Frequency (in MHz) for which to return GSM model. lmax (int): Maximum ell value for alms nside (int): The nside to upgrade/downgrade the map to. Default is nside=64. resolution (str): if \"low/lo/l\": The GSM nside = 64 (default) if \"hi/high/h\": The GSM nside = 1024 output_model (bool): If output_model=True: Outputs model generated from the GSM data. If output_model=False (default): no model output. output_map (bool): If output_map=True: Outputs map generated from the GSM data. If output_map=False (default): no map output. Returns: healpy_modes (array_like): Complex array of alms with same size and ordering as in healpy (m,l) gsm_2016 (PyGDSM 2016 model): If output_model=True: Outputs model generated from the GSM data. If output_model=False (default): no model output. gsm_map (healpy map): If output_map=True: Outputs map generated from the GSM data. If output_map=False (default): no map output. \"\"\" # Instantiate GSM model and extract alms try: gsm_2016 = pygdsm.GlobalSkyModel2016(freq_unit=\"MHz\", resolution=resolution) except(AttributeError): gsm_2016 = pygdsm.GlobalSkyModel16(freq_unit=\"MHz\", resolution=resolution) gsm_map = gsm_2016.generate(freqs=freq) gsm_upgrade = hp.ud_grade(gsm_map, nside) healpy_modes_gal = np.array([hp.map2alm(maps=_map, lmax=lmax) for _map in gsm_upgrade]) # By default it is in gal-coordinates, convert to equatorial rot_gal2eq = hp.Rotator(coord=\"GC\") healpy_modes_eq = np.array([rot_gal2eq.rotate_alm(_modes) for _modes in healpy_modes_gal]) if output_model == False and output_map == False: # default return healpy_modes_eq elif output_model == False and output_map == True: return healpy_modes_eq, gsm_map elif output_model == True and output_map == False: return healpy_modes_eq, gsm_2016 else: return healpy_modes_eq, gsm_2016, gsm_map healpy2alms(healpy_modes) Takes a complex array of alms (positive modes only) and turns into a real array split as [real, imag] making sure to remove the m=0 modes from the imag-part. Parameters: Name Type Description Default healpy_modes ( array_like , complex ) Array of zeros except for the specified mode. The array represents all positive (+m) modes including zeroth modes. required Returns: Name Type Description alms array_like Array of zeros except for the specified mode. The array represents all positive (+m) modes including zero and is split into a real (first) and imag (second) part. The Imag part is smaller as the m=0 modes shouldn't contain and imaginary part. Source code in hydra/sh_sampler.py def healpy2alms(healpy_modes): \"\"\" Takes a complex array of alms (positive modes only) and turns into a real array split as [real, imag] making sure to remove the m=0 modes from the imag-part. Parameters: healpy_modes (array_like, complex): Array of zeros except for the specified mode. The array represents all positive (+m) modes including zeroth modes. Returns: alms (array_like): Array of zeros except for the specified mode. The array represents all positive (+m) modes including zero and is split into a real (first) and imag (second) part. The Imag part is smaller as the m=0 modes shouldn't contain and imaginary part. \"\"\" if len(healpy_modes.shape) == 1: # Split healpy mode array into read and imaginary parts, with m=0 # imaginary modes excluded (since they are always zero for a real field) lmax = hp.sphtfunc.Alm.getlmax(healpy_modes.size) # to remove the m=0 imag modes alms = np.concatenate((healpy_modes.real, healpy_modes.imag[(lmax + 1) :])) return alms elif len(healpy_modes.shape) == 2: # Loop through elements of the 2D input array (recursive) return np.array([healpy2alms(_map) for _map in healpy_modes]) else: raise ValueError(\"Input array must have shape (Nmodes,) or (Nmaps, Nmodes).\") sample_cl(alms, ell, m) Sample C_ell from an inverse gamma distribution, given a set of SH coefficients. See Eq. 7 of Eriksen et al. (arXiv:0709.1058). Source code in hydra/sh_sampler.py def sample_cl(alms, ell, m): \"\"\" Sample C_ell from an inverse gamma distribution, given a set of SH coefficients. See Eq. 7 of Eriksen et al. (arXiv:0709.1058). \"\"\" # Get m, ell ordering m_vals, ell_vals, lm_idxs = get_em_ell_idx(lmax) # Calculate sigma_ell = 1/(2 l + 1) sum_m |a_lm|^2 for ell in np.unique(ell_vals): idxs = np.where(ell_vals == ell) vis_proj_operator_no_rot(freqs, lsts, beams, ant_pos, lmax, nside, latitude=-0.5361913261514378, include_autos=False, autos_only=False, ref_freq=100.0, spectral_idx=0.0) Precompute the real and imaginary blocks of the visibility response operator. This should only be done once and then \"apply_vis_response()\" is used to get the actual visibilities. Parameters: Name Type Description Default freqs array_like Frequencies, in MHz. required lsts array_like LSTs (times) for the simulation. In radians. required beams list of pyuvbeam List of pyuveam objects, one for each antenna required ant_pos dict Dictionary of antenna positions, [x, y, z], in m. The keys should be the numerical antenna IDs. required lmax int Maximum ell value. Determines the number of modes used. required nside int Healpix nside to use for the calculation (longer baselines should use higher nside). required latitude float Latitude in decimal format of the simulated array/visibilities. -0.5361913261514378 include_autos bool If True , the auto baselines are included. False ref_freq float Reference frequency for the spectral dependence, in MHz. 100.0 spectral_idx float Spectral index, beta , for the spectral dependence, ~(freqs / ref_freq)^beta . 0.0 Returns: Name Type Description vis_response_2D array_like Visibility operator (\u03b4V_ij) for each (l,m) mode, frequency, baseline and lst. Shape (Nvis, Nalms) where Nvis is Nbl x Ntimes x Nfreqs. ell array of int Array of ell-values for the visiblity simulation m array of int Array of ell-values for the visiblity simulation Source code in hydra/sh_sampler.py def vis_proj_operator_no_rot( freqs, lsts, beams, ant_pos, lmax, nside, latitude=-0.5361913261514378, include_autos=False, autos_only=False, ref_freq=100.0, spectral_idx=0.0, ): \"\"\" Precompute the real and imaginary blocks of the visibility response operator. This should only be done once and then \"apply_vis_response()\" is used to get the actual visibilities. Parameters: freqs (array_like): Frequencies, in MHz. lsts (array_like): LSTs (times) for the simulation. In radians. beams (list of pyuvbeam): List of pyuveam objects, one for each antenna ant_pos (dict): Dictionary of antenna positions, [x, y, z], in m. The keys should be the numerical antenna IDs. lmax (int): Maximum ell value. Determines the number of modes used. nside (int): Healpix nside to use for the calculation (longer baselines should use higher nside). latitude (float): Latitude in decimal format of the simulated array/visibilities. include_autos (bool): If `True`, the auto baselines are included. ref_freq (float): Reference frequency for the spectral dependence, in MHz. spectral_idx (float): Spectral index, `beta`, for the spectral dependence, `~(freqs / ref_freq)^beta`. Returns: vis_response_2D (array_like): Visibility operator (\u03b4V_ij) for each (l,m) mode, frequency, baseline and lst. Shape (Nvis, Nalms) where Nvis is Nbl x Ntimes x Nfreqs. ell (array of int): Array of ell-values for the visiblity simulation m (array of int): Array of ell-values for the visiblity simulation \"\"\" ell, m, vis_alm = simulate_vis_per_alm( lmax=lmax, nside=nside, ants=ant_pos, freqs=freqs * 1e6, # MHz -> Hz lsts=lsts, beams=beams, latitude=latitude, ) # Removing visibility responses corresponding to the m=0 imaginary parts vis_alm = np.concatenate( (vis_alm[:, :, :, :, : len(ell)], vis_alm[:, :, :, :, len(ell) + (lmax + 1) :]), axis=4, ) ants = list(ant_pos.keys()) antpairs = [] if autos_only == False and include_autos == False: auto_ants = [] for i in ants: for j in ants: # Toggle via keyword argument if you want to keep the auto baselines/only have autos if include_autos == True: if j >= i: antpairs.append((ants[i], ants[j])) elif autos_only == True: if j == i: antpairs.append((ants[i], ants[j])) else: if j == i: auto_ants.append((ants[i], ants[j])) if j > i: antpairs.append((ants[i], ants[j])) vis_response = np.zeros( (len(antpairs), len(freqs), len(lsts), 2 * len(ell) - (lmax + 1)), dtype=np.complex128, ) ## Collapse the two antenna dimensions into one baseline dimension # Nfreqs, Ntimes, Nant1, Nant2, Nalms --> Nbl, Nfreqs, Ntimes, Nalms for i, bl in enumerate(antpairs): idx1 = ants.index(bl[0]) idx2 = ants.index(bl[1]) vis_response[i, :] = vis_alm[:, :, idx1, idx2, :] # Multiply by spectral dependence model (a powerlaw) # Shape: Nbl, Nfreqs, Ntimes, Nalms vis_response *= ((freqs / ref_freq) ** spectral_idx)[ np.newaxis, :, np.newaxis, np.newaxis ] # Reshape to 2D # TODO: Make this into a \"pack\" and \"unpack\" function # Nbl, Nfreqs, Ntimes, Nalms --> Nvis, Nalms Nvis = len(antpairs) * len(freqs) * len(lsts) vis_response_2D = vis_response.reshape(Nvis, 2 * len(ell) - (lmax + 1)) if autos_only == False and include_autos == False: autos = np.zeros( (len(auto_ants), len(freqs), len(lsts), 2 * len(ell) - (lmax + 1)), dtype=np.complex128, ) ## Collapse the two antenna dimensions into one baseline dimension # Nfreqs, Ntimes, Nant1, Nant2, Nalms --> Nbl, Nfreqs, Ntimes, Nalms for i, bl in enumerate(auto_ants): idx1 = ants.index(bl[0]) idx2 = ants.index(bl[1]) autos[i, :] = vis_alm[:, :, idx1, idx2, :] ## Reshape to 2D ## TODO: Make this into a \"pack\" and \"unpack\" function # Nbl, Nfreqs, Ntimes, Nalms --> Nvis, Nalms Nautos = len(auto_ants) * len(freqs) * len(lsts) autos_2D = autos.reshape(Nautos, 2 * len(ell) - (lmax + 1)) return vis_response_2D, autos_2D, ell, m else: return vis_response_2D, ell, m","title":"Spherical harmonic sampler (sh_sampler)"},{"location":"sh_sampler/#spherical-harmonic-sampler-sh_sampler","text":"","title":"Spherical harmonic sampler (sh_sampler)"},{"location":"sh_sampler/#hydra.sh_sampler.alms2healpy","text":"Takes a real array split as [real, imag] (without the m=0 modes imag-part) and turns it into a complex array of alms (positive modes only) ordered as in HEALpy. Parameters: Name Type Description Default alms array_like Array of zeros except for the specified mode. The array represents all positive (+m) modes including zero and has double length, as real and imaginary values are split. The first half is the real values. required Returns: Name Type Description healpy_modes array_like Array of zeros except for the specified mode. The array represents all positive (+m) modes including zeroth modes. Source code in hydra/sh_sampler.py def alms2healpy(alms, lmax): \"\"\" Takes a real array split as [real, imag] (without the m=0 modes imag-part) and turns it into a complex array of alms (positive modes only) ordered as in HEALpy. Parameters: alms (array_like): Array of zeros except for the specified mode. The array represents all positive (+m) modes including zero and has double length, as real and imaginary values are split. The first half is the real values. Returns: healpy_modes (array_like): Array of zeros except for the specified mode. The array represents all positive (+m) modes including zeroth modes. \"\"\" if len(alms.shape) == 1: # Combine real and imaginary parts into alm format expected by healpy real_imag_split_index = int((np.size(alms) + (lmax + 1)) / 2) real = alms[:real_imag_split_index] add_imag_m0_modes = np.zeros(lmax + 1) # add m=0 imag. modes back in imag = np.concatenate((add_imag_m0_modes, alms[real_imag_split_index:])) healpy_modes = real + 1.0j * imag return healpy_modes elif len(alms.shape) == 2: # Handle 2D array case (loop over entries) with a recursion return np.array([alms2healpy(modes, lmax) for modes in alms]) else: raise ValueError(\"alms array must either have shape (Nmodes,) or (Nmaps, Nmodes)\")","title":"alms2healpy"},{"location":"sh_sampler/#hydra.sh_sampler.apply_lhs_no_rot","text":"Apply LHS operator of linear system to an input vector. Source code in hydra/sh_sampler.py def apply_lhs_no_rot(a_cr, inv_noise_var, inv_prior_var, vis_response): \"\"\" Apply LHS operator of linear system to an input vector. \"\"\" real_noise_term = ( vis_response.real.T @ (inv_noise_var[:, np.newaxis] * vis_response.real) @ a_cr ) imag_noise_term = ( vis_response.imag.T @ (inv_noise_var[:, np.newaxis] * vis_response.imag) @ a_cr ) signal_term = inv_prior_var * a_cr left_hand_side = real_noise_term + imag_noise_term + signal_term return left_hand_side","title":"apply_lhs_no_rot"},{"location":"sh_sampler/#hydra.sh_sampler.apply_lhs_no_rot_mpi","text":"Apply LHS operator of linear system to an input vector that has been split into chunks between MPI workers. Source code in hydra/sh_sampler.py def apply_lhs_no_rot_mpi(comm, a_cr, inv_noise_var, inv_prior_var, vis_response): \"\"\" Apply LHS operator of linear system to an input vector that has been split into chunks between MPI workers. \"\"\" if comm is not None: myid = comm.Get_rank() else: myid = 0 # Synchronise a_cr across all workers if myid != 0: a_cr *= 0. if comm is not None: comm.Bcast(a_cr, root=0) # Calculate noise terms for this rank my_tot_noise_term = ( vis_response.real.T @ (inv_noise_var.flatten()[:, np.newaxis] * vis_response.real) @ a_cr + vis_response.imag.T @ (inv_noise_var.flatten()[:, np.newaxis] * vis_response.imag) @ a_cr ) # Do Reduce (sum) operation to get total operator on root node tot_noise_term = np.zeros( (1,), dtype=my_tot_noise_term.dtype ) # dummy data for non-root workers if myid == 0: tot_noise_term = np.zeros_like(my_tot_noise_term) if comm is not None: comm.Reduce(my_tot_noise_term, tot_noise_term, op=MPI_SUM, root=0) else: tot_noise_term = my_tot_noise_term # Return result (only root worker has correct result) if myid == 0: signal_term = inv_prior_var * a_cr return tot_noise_term + signal_term else: return np.zeros_like(a_cr)","title":"apply_lhs_no_rot_mpi"},{"location":"sh_sampler/#hydra.sh_sampler.construct_rhs_no_rot","text":"Construct RHS of linear system. Source code in hydra/sh_sampler.py def construct_rhs_no_rot( data, inv_noise_var, inv_prior_var, omega_0, omega_1, a_0, vis_response ): \"\"\" Construct RHS of linear system. \"\"\" real_data_term = vis_response.real.T @ ( inv_noise_var * data.real + np.sqrt(inv_noise_var) * omega_1.real ) imag_data_term = vis_response.imag.T @ ( inv_noise_var * data.imag + np.sqrt(inv_noise_var) * omega_1.imag ) prior_term = inv_prior_var * a_0 + np.sqrt(inv_prior_var) * omega_0 right_hand_side = real_data_term + imag_data_term + prior_term return right_hand_side","title":"construct_rhs_no_rot"},{"location":"sh_sampler/#hydra.sh_sampler.construct_rhs_no_rot_mpi","text":"Construct RHS of linear system from data split across multiple MPI workers. Source code in hydra/sh_sampler.py def construct_rhs_no_rot_mpi( comm, data, inv_noise_var, inv_prior_var, omega_a, omega_n, a_0, vis_response ): \"\"\" Construct RHS of linear system from data split across multiple MPI workers. \"\"\" if comm is not None: myid = comm.Get_rank() else: myid = 0 # Synchronise omega_a across all workers if myid != 0: omega_a *= 0. if comm is not None: comm.Bcast(omega_a, root=0) # Calculate data terms my_data_term = vis_response.real.T @ ( (inv_noise_var * data.real).flatten() + np.sqrt(inv_noise_var).flatten() * omega_n.real.flatten() ) + vis_response.imag.T @ ( (inv_noise_var * data.imag).flatten() + np.sqrt(inv_noise_var).flatten() * omega_n.imag.flatten() ) # Do Reduce (sum) operation to get total operator on root node data_term = np.zeros( (1,), dtype=my_data_term.dtype ) # dummy data for non-root workers if myid == 0: data_term = np.zeros_like(my_data_term) if comm is not None: comm.Reduce(my_data_term, data_term, op=MPI_SUM, root=0) comm.barrier() else: data_term = my_data_term # Return result (only root worker has correct result) if myid == 0: return data_term + inv_prior_var * a_0 + np.sqrt(inv_prior_var) * omega_a else: return np.zeros_like(a_0)","title":"construct_rhs_no_rot_mpi"},{"location":"sh_sampler/#hydra.sh_sampler.get_alms_from_gsm","text":"Generate a real array split as [real, imag] (without the m=0 modes imag-part) from gsm 2016 (https://github.com/telegraphic/pygdsm) freqs (float or array_like): Frequency (in MHz) for which to return GSM model lmax (int): Maximum ell value for alms nside (int): The nside to upgrade/downgrade the map to. Default is nside=64. resolution (str): if \"low/lo/l\": nside = 64 (default) if \"hi/high/h\": nside = 1024 output_model (bool): If output_model=True: Outputs model generated from the GSM data. If output_model=False (default): no model output. output_map (bool): If output_map=True: Outputs map generated from the GSM data. If output_map=False (default): no map output. Returns: Name Type Description alms array_like Array of zeros except for the specified mode. The array represents all positive (+m) modes including zero and has double length, as real and imaginary values are split. The first half is the real values. gsm_2016 PyGDSM 2016 model If output_model=True: Outputs model generated from the GSM data. If output_model=False (default): no model output. gsm_map healpy map If output_map=True: Outputs map generated from the GSM data. If output_map=False (default): no map output. Source code in hydra/sh_sampler.py def get_alms_from_gsm( freq, lmax, nside=64, resolution=\"low\", output_model=False, output_map=False ): \"\"\" Generate a real array split as [real, imag] (without the m=0 modes imag-part) from gsm 2016 (https://github.com/telegraphic/pygdsm) Parameters: freqs (float or array_like): Frequency (in MHz) for which to return GSM model lmax (int): Maximum ell value for alms nside (int): The nside to upgrade/downgrade the map to. Default is nside=64. resolution (str): if \"low/lo/l\": nside = 64 (default) if \"hi/high/h\": nside = 1024 output_model (bool): If output_model=True: Outputs model generated from the GSM data. If output_model=False (default): no model output. output_map (bool): If output_map=True: Outputs map generated from the GSM data. If output_map=False (default): no map output. Returns: alms (array_like): Array of zeros except for the specified mode. The array represents all positive (+m) modes including zero and has double length, as real and imaginary values are split. The first half is the real values. gsm_2016 (PyGDSM 2016 model): If output_model=True: Outputs model generated from the GSM data. If output_model=False (default): no model output. gsm_map (healpy map): If output_map=True: Outputs map generated from the GSM data. If output_map=False (default): no map output. \"\"\" return healpy2alms( get_healpy_from_gsm(freq, lmax, nside, resolution, output_model, output_map) )","title":"get_alms_from_gsm"},{"location":"sh_sampler/#hydra.sh_sampler.get_em_ell_idx","text":"With (m,l) ordering! Source code in hydra/sh_sampler.py def get_em_ell_idx(lmax): \"\"\" With (m,l) ordering! \"\"\" ells_list = np.arange(0, lmax + 1) em_real = np.arange(0, lmax + 1) em_imag = np.arange(1, lmax + 1) # ylabel = [] # First append all real (l,m) values Nreal = 0 i = 0 idx = [] ems = [] ells = [] for em in em_real: for ell in ells_list: if ell >= em: idx.append(i) ems.append(em) ells.append(ell) Nreal += 1 i += 1 # Then all imaginary -- note: no m=0 modes! Nimag = 0 for em in em_imag: for ell in ells_list: if ell >= em: idx.append(i) ems.append(em) ells.append(ell) Nimag += 1 i += 1 return ems, ells, idx","title":"get_em_ell_idx"},{"location":"sh_sampler/#hydra.sh_sampler.get_healpy_from_gsm","text":"Generate an array of alms (HEALpy ordered) from gsm 2016 (https://github.com/telegraphic/pygdsm) Parameters: Name Type Description Default freqs array_like Frequency (in MHz) for which to return GSM model. required lmax int Maximum ell value for alms required nside int The nside to upgrade/downgrade the map to. Default is nside=64. 64 resolution str if \"low/lo/l\": The GSM nside = 64 (default) if \"hi/high/h\": The GSM nside = 1024 'low' output_model bool If output_model=True: Outputs model generated from the GSM data. If output_model=False (default): no model output. False output_map bool If output_map=True: Outputs map generated from the GSM data. If output_map=False (default): no map output. False Returns: Name Type Description healpy_modes array_like Complex array of alms with same size and ordering as in healpy (m,l) gsm_2016 PyGDSM 2016 model If output_model=True: Outputs model generated from the GSM data. If output_model=False (default): no model output. gsm_map healpy map If output_map=True: Outputs map generated from the GSM data. If output_map=False (default): no map output. Source code in hydra/sh_sampler.py def get_healpy_from_gsm( freq, lmax, nside=64, resolution=\"low\", output_model=False, output_map=False ): \"\"\" Generate an array of alms (HEALpy ordered) from gsm 2016 (https://github.com/telegraphic/pygdsm) Parameters: freqs (array_like): Frequency (in MHz) for which to return GSM model. lmax (int): Maximum ell value for alms nside (int): The nside to upgrade/downgrade the map to. Default is nside=64. resolution (str): if \"low/lo/l\": The GSM nside = 64 (default) if \"hi/high/h\": The GSM nside = 1024 output_model (bool): If output_model=True: Outputs model generated from the GSM data. If output_model=False (default): no model output. output_map (bool): If output_map=True: Outputs map generated from the GSM data. If output_map=False (default): no map output. Returns: healpy_modes (array_like): Complex array of alms with same size and ordering as in healpy (m,l) gsm_2016 (PyGDSM 2016 model): If output_model=True: Outputs model generated from the GSM data. If output_model=False (default): no model output. gsm_map (healpy map): If output_map=True: Outputs map generated from the GSM data. If output_map=False (default): no map output. \"\"\" # Instantiate GSM model and extract alms try: gsm_2016 = pygdsm.GlobalSkyModel2016(freq_unit=\"MHz\", resolution=resolution) except(AttributeError): gsm_2016 = pygdsm.GlobalSkyModel16(freq_unit=\"MHz\", resolution=resolution) gsm_map = gsm_2016.generate(freqs=freq) gsm_upgrade = hp.ud_grade(gsm_map, nside) healpy_modes_gal = np.array([hp.map2alm(maps=_map, lmax=lmax) for _map in gsm_upgrade]) # By default it is in gal-coordinates, convert to equatorial rot_gal2eq = hp.Rotator(coord=\"GC\") healpy_modes_eq = np.array([rot_gal2eq.rotate_alm(_modes) for _modes in healpy_modes_gal]) if output_model == False and output_map == False: # default return healpy_modes_eq elif output_model == False and output_map == True: return healpy_modes_eq, gsm_map elif output_model == True and output_map == False: return healpy_modes_eq, gsm_2016 else: return healpy_modes_eq, gsm_2016, gsm_map","title":"get_healpy_from_gsm"},{"location":"sh_sampler/#hydra.sh_sampler.healpy2alms","text":"Takes a complex array of alms (positive modes only) and turns into a real array split as [real, imag] making sure to remove the m=0 modes from the imag-part. Parameters: Name Type Description Default healpy_modes ( array_like , complex ) Array of zeros except for the specified mode. The array represents all positive (+m) modes including zeroth modes. required Returns: Name Type Description alms array_like Array of zeros except for the specified mode. The array represents all positive (+m) modes including zero and is split into a real (first) and imag (second) part. The Imag part is smaller as the m=0 modes shouldn't contain and imaginary part. Source code in hydra/sh_sampler.py def healpy2alms(healpy_modes): \"\"\" Takes a complex array of alms (positive modes only) and turns into a real array split as [real, imag] making sure to remove the m=0 modes from the imag-part. Parameters: healpy_modes (array_like, complex): Array of zeros except for the specified mode. The array represents all positive (+m) modes including zeroth modes. Returns: alms (array_like): Array of zeros except for the specified mode. The array represents all positive (+m) modes including zero and is split into a real (first) and imag (second) part. The Imag part is smaller as the m=0 modes shouldn't contain and imaginary part. \"\"\" if len(healpy_modes.shape) == 1: # Split healpy mode array into read and imaginary parts, with m=0 # imaginary modes excluded (since they are always zero for a real field) lmax = hp.sphtfunc.Alm.getlmax(healpy_modes.size) # to remove the m=0 imag modes alms = np.concatenate((healpy_modes.real, healpy_modes.imag[(lmax + 1) :])) return alms elif len(healpy_modes.shape) == 2: # Loop through elements of the 2D input array (recursive) return np.array([healpy2alms(_map) for _map in healpy_modes]) else: raise ValueError(\"Input array must have shape (Nmodes,) or (Nmaps, Nmodes).\")","title":"healpy2alms"},{"location":"sh_sampler/#hydra.sh_sampler.sample_cl","text":"Sample C_ell from an inverse gamma distribution, given a set of SH coefficients. See Eq. 7 of Eriksen et al. (arXiv:0709.1058). Source code in hydra/sh_sampler.py def sample_cl(alms, ell, m): \"\"\" Sample C_ell from an inverse gamma distribution, given a set of SH coefficients. See Eq. 7 of Eriksen et al. (arXiv:0709.1058). \"\"\" # Get m, ell ordering m_vals, ell_vals, lm_idxs = get_em_ell_idx(lmax) # Calculate sigma_ell = 1/(2 l + 1) sum_m |a_lm|^2 for ell in np.unique(ell_vals): idxs = np.where(ell_vals == ell)","title":"sample_cl"},{"location":"sh_sampler/#hydra.sh_sampler.vis_proj_operator_no_rot","text":"Precompute the real and imaginary blocks of the visibility response operator. This should only be done once and then \"apply_vis_response()\" is used to get the actual visibilities. Parameters: Name Type Description Default freqs array_like Frequencies, in MHz. required lsts array_like LSTs (times) for the simulation. In radians. required beams list of pyuvbeam List of pyuveam objects, one for each antenna required ant_pos dict Dictionary of antenna positions, [x, y, z], in m. The keys should be the numerical antenna IDs. required lmax int Maximum ell value. Determines the number of modes used. required nside int Healpix nside to use for the calculation (longer baselines should use higher nside). required latitude float Latitude in decimal format of the simulated array/visibilities. -0.5361913261514378 include_autos bool If True , the auto baselines are included. False ref_freq float Reference frequency for the spectral dependence, in MHz. 100.0 spectral_idx float Spectral index, beta , for the spectral dependence, ~(freqs / ref_freq)^beta . 0.0 Returns: Name Type Description vis_response_2D array_like Visibility operator (\u03b4V_ij) for each (l,m) mode, frequency, baseline and lst. Shape (Nvis, Nalms) where Nvis is Nbl x Ntimes x Nfreqs. ell array of int Array of ell-values for the visiblity simulation m array of int Array of ell-values for the visiblity simulation Source code in hydra/sh_sampler.py def vis_proj_operator_no_rot( freqs, lsts, beams, ant_pos, lmax, nside, latitude=-0.5361913261514378, include_autos=False, autos_only=False, ref_freq=100.0, spectral_idx=0.0, ): \"\"\" Precompute the real and imaginary blocks of the visibility response operator. This should only be done once and then \"apply_vis_response()\" is used to get the actual visibilities. Parameters: freqs (array_like): Frequencies, in MHz. lsts (array_like): LSTs (times) for the simulation. In radians. beams (list of pyuvbeam): List of pyuveam objects, one for each antenna ant_pos (dict): Dictionary of antenna positions, [x, y, z], in m. The keys should be the numerical antenna IDs. lmax (int): Maximum ell value. Determines the number of modes used. nside (int): Healpix nside to use for the calculation (longer baselines should use higher nside). latitude (float): Latitude in decimal format of the simulated array/visibilities. include_autos (bool): If `True`, the auto baselines are included. ref_freq (float): Reference frequency for the spectral dependence, in MHz. spectral_idx (float): Spectral index, `beta`, for the spectral dependence, `~(freqs / ref_freq)^beta`. Returns: vis_response_2D (array_like): Visibility operator (\u03b4V_ij) for each (l,m) mode, frequency, baseline and lst. Shape (Nvis, Nalms) where Nvis is Nbl x Ntimes x Nfreqs. ell (array of int): Array of ell-values for the visiblity simulation m (array of int): Array of ell-values for the visiblity simulation \"\"\" ell, m, vis_alm = simulate_vis_per_alm( lmax=lmax, nside=nside, ants=ant_pos, freqs=freqs * 1e6, # MHz -> Hz lsts=lsts, beams=beams, latitude=latitude, ) # Removing visibility responses corresponding to the m=0 imaginary parts vis_alm = np.concatenate( (vis_alm[:, :, :, :, : len(ell)], vis_alm[:, :, :, :, len(ell) + (lmax + 1) :]), axis=4, ) ants = list(ant_pos.keys()) antpairs = [] if autos_only == False and include_autos == False: auto_ants = [] for i in ants: for j in ants: # Toggle via keyword argument if you want to keep the auto baselines/only have autos if include_autos == True: if j >= i: antpairs.append((ants[i], ants[j])) elif autos_only == True: if j == i: antpairs.append((ants[i], ants[j])) else: if j == i: auto_ants.append((ants[i], ants[j])) if j > i: antpairs.append((ants[i], ants[j])) vis_response = np.zeros( (len(antpairs), len(freqs), len(lsts), 2 * len(ell) - (lmax + 1)), dtype=np.complex128, ) ## Collapse the two antenna dimensions into one baseline dimension # Nfreqs, Ntimes, Nant1, Nant2, Nalms --> Nbl, Nfreqs, Ntimes, Nalms for i, bl in enumerate(antpairs): idx1 = ants.index(bl[0]) idx2 = ants.index(bl[1]) vis_response[i, :] = vis_alm[:, :, idx1, idx2, :] # Multiply by spectral dependence model (a powerlaw) # Shape: Nbl, Nfreqs, Ntimes, Nalms vis_response *= ((freqs / ref_freq) ** spectral_idx)[ np.newaxis, :, np.newaxis, np.newaxis ] # Reshape to 2D # TODO: Make this into a \"pack\" and \"unpack\" function # Nbl, Nfreqs, Ntimes, Nalms --> Nvis, Nalms Nvis = len(antpairs) * len(freqs) * len(lsts) vis_response_2D = vis_response.reshape(Nvis, 2 * len(ell) - (lmax + 1)) if autos_only == False and include_autos == False: autos = np.zeros( (len(auto_ants), len(freqs), len(lsts), 2 * len(ell) - (lmax + 1)), dtype=np.complex128, ) ## Collapse the two antenna dimensions into one baseline dimension # Nfreqs, Ntimes, Nant1, Nant2, Nalms --> Nbl, Nfreqs, Ntimes, Nalms for i, bl in enumerate(auto_ants): idx1 = ants.index(bl[0]) idx2 = ants.index(bl[1]) autos[i, :] = vis_alm[:, :, idx1, idx2, :] ## Reshape to 2D ## TODO: Make this into a \"pack\" and \"unpack\" function # Nbl, Nfreqs, Ntimes, Nalms --> Nvis, Nalms Nautos = len(auto_ants) * len(freqs) * len(lsts) autos_2D = autos.reshape(Nautos, 2 * len(ell) - (lmax + 1)) return vis_response_2D, autos_2D, ell, m else: return vis_response_2D, ell, m","title":"vis_proj_operator_no_rot"}]}